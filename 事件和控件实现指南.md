# Termux:GUI äº‹ä»¶å’Œæ§ä»¶å®ç°æŒ‡å—

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜å¦‚ä½•åœ¨ Rust ç‰ˆæœ¬ä¸­å®ç°å®Œæ•´çš„äº‹ä»¶å¤„ç†å’Œå„ç§ GUI æ§ä»¶ï¼ŒåŸºäº Python å®ç°è¿›è¡Œå¯¹æ¯”åˆ†æã€‚

## äº‹ä»¶ç³»ç»Ÿæ¶æ„

### Python å®ç°åˆ†æ

#### äº‹ä»¶ç±»å‹ï¼ˆEvent Typesï¼‰

```python
class Event:
    # View äº‹ä»¶
    click = "click"                    # ç‚¹å‡»äº‹ä»¶
    longClick = "longClick"            # é•¿æŒ‰äº‹ä»¶
    focusChange = "focusChange"        # ç„¦ç‚¹å˜åŒ–
    key = "key"                        # æŒ‰é”®äº‹ä»¶
    touch = "touch"                    # è§¦æ‘¸äº‹ä»¶
    refresh = "refresh"                # åˆ·æ–°äº‹ä»¶
    selected = "selected"              # é€‰ä¸­äº‹ä»¶ï¼ˆRadioGroupï¼‰
    itemselected = "itemselected"      # é¡¹ç›®é€‰ä¸­ï¼ˆSpinnerï¼‰
    text = "text"                      # æ–‡æœ¬å˜åŒ–ï¼ˆEditTextï¼‰
    
    # Activity äº‹ä»¶
    create = "create"                  # Activity åˆ›å»º
    start = "start"                    # Activity å¯åŠ¨
    resume = "resume"                  # Activity æ¢å¤
    pause = "pause"                    # Activity æš‚åœ
    stop = "stop"                      # Activity åœæ­¢
    destroy = "destroy"                # Activity é”€æ¯
    back = "back"                      # è¿”å›é”®
    
    # å…¶ä»–äº‹ä»¶
    notification = "notification"       # é€šçŸ¥ç‚¹å‡»
    webviewNavigation = "webviewNavigation"  # WebView å¯¼èˆª
```

#### äº‹ä»¶ç»“æ„

```python
# äº‹ä»¶ JSON æ ¼å¼
{
    "type": "click",           # äº‹ä»¶ç±»å‹
    "value": {
        "aid": 0,             # Activity ID
        "id": 42,             # View ID
        # é¢å¤–å­—æ®µæ ¹æ®äº‹ä»¶ç±»å‹ä¸åŒ
        "set": true,          # Checkbox/Switch çŠ¶æ€
        "selected": 1,        # é€‰ä¸­çš„é¡¹ç›®
        "text": "content",    # EditText å†…å®¹
        "finishing": true     # Activity æ˜¯å¦æ­£åœ¨ç»“æŸ
    }
}
```

### Rust å®ç°è®¾è®¡

#### 1. äº‹ä»¶æšä¸¾å®šä¹‰

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum EventType {
    // View äº‹ä»¶
    Click,
    LongClick,
    FocusChange,
    Key,
    Touch,
    Text,
    Refresh,
    Selected,
    ItemSelected,
    
    // Activity äº‹ä»¶
    Create,
    Start,
    Resume,
    Pause,
    Stop,
    Destroy,
    Back,
    
    // å…¶ä»–
    Notification,
    WebviewNavigation,
    Unknown(String),
}

impl From<&str> for EventType {
    fn from(s: &str) -> Self {
        match s {
            "click" => EventType::Click,
            "longClick" => EventType::LongClick,
            "focusChange" => EventType::FocusChange,
            "text" => EventType::Text,
            "selected" => EventType::Selected,
            "itemselected" => EventType::ItemSelected,
            "create" => EventType::Create,
            "start" => EventType::Start,
            "resume" => EventType::Resume,
            "pause" => EventType::Pause,
            "stop" => EventType::Stop,
            "destroy" => EventType::Destroy,
            "back" => EventType::Back,
            _ => EventType::Unknown(s.to_string()),
        }
    }
}
```

#### 2. äº‹ä»¶æ•°æ®ç»“æ„

```rust
#[derive(Debug, Clone)]
pub struct Event {
    pub event_type: EventType,
    pub aid: Option<i64>,
    pub view_id: Option<i64>,
    pub data: EventData,
}

#[derive(Debug, Clone)]
pub enum EventData {
    Click,
    Checked { set: bool },                    // Checkbox/Switch
    Selected { selected: i64 },               // RadioGroup
    ItemSelected { selected: String },        // Spinner
    Text { text: String },                    // EditText
    Destroy { finishing: bool },
    None,
}

impl Event {
    pub fn from_json(value: &Value) -> Result<Self, String> {
        let event_type = value["type"]
            .as_str()
            .ok_or("Missing event type")?
            .into();
            
        let val = &value["value"];
        let aid = val["aid"].as_i64();
        let view_id = val["id"].as_i64();
        
        let data = match event_type {
            EventType::Click if val["set"].is_boolean() => {
                EventData::Checked {
                    set: val["set"].as_bool().unwrap(),
                }
            },
            EventType::Selected => {
                EventData::Selected {
                    selected: val["selected"].as_i64().unwrap_or(0),
                }
            },
            EventType::ItemSelected => {
                EventData::ItemSelected {
                    selected: val["selected"].as_str().unwrap_or("").to_string(),
                }
            },
            EventType::Text => {
                EventData::Text {
                    text: val["text"].as_str().unwrap_or("").to_string(),
                }
            },
            EventType::Destroy => {
                EventData::Destroy {
                    finishing: val["finishing"].as_bool().unwrap_or(false),
                }
            },
            _ => EventData::None,
        };
        
        Ok(Event {
            event_type,
            aid,
            view_id,
            data,
        })
    }
}
```

---

## æ§ä»¶ç³»ç»Ÿæ¶æ„

### åŸºç¡€ View ç»“æ„

#### Python å®ç°

```python
class View:
    def __init__(self, activity: Activity, id: int):
        self.a = activity
        self.id = id
    
    def delete(self):
        self.a.c.send_msg({
            "method": "deleteView",
            "params": {"aid": self.a.aid, "id": self.id}
        })
    
    def setwidth(self, width: Union[int, str], px: bool = False):
        self.a.c.send_msg({
            "method": "setWidth",
            "params": {"aid": self.a.aid, "id": self.id, "width": width, "px": px}
        })
```

#### Rust å®ç°

```rust
pub struct View {
    pub activity_id: i64,
    pub id: i64,
}

impl View {
    pub fn new(activity_id: i64, id: i64) -> Self {
        View { activity_id, id }
    }
    
    pub fn delete(&self, stream: &mut UnixStream) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "deleteView",
            "params": {
                "aid": self.activity_id,
                "id": self.id
            }
        }))
    }
    
    pub fn set_width(&self, stream: &mut UnixStream, width: ViewSize, px: bool) -> Result<(), Error> {
        let width_value = match width {
            ViewSize::Fixed(w) => json!(w),
            ViewSize::WrapContent => json!("WRAP_CONTENT"),
            ViewSize::MatchParent => json!("MATCH_PARENT"),
        };
        
        send_message(stream, &json!({
            "method": "setWidth",
            "params": {
                "aid": self.activity_id,
                "id": self.id,
                "width": width_value,
                "px": px
            }
        }))
    }
    
    pub fn set_background_color(&self, stream: &mut UnixStream, color: i32) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "setBackgroundColor",
            "params": {
                "aid": self.activity_id,
                "id": self.id,
                "color": color
            }
        }))
    }
    
    pub fn send_click_event(&self, stream: &mut UnixStream, send: bool) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "sendClickEvent",
            "params": {
                "aid": self.activity_id,
                "id": self.id,
                "send": send
            }
        }))
    }
}

pub enum ViewSize {
    Fixed(i32),
    WrapContent,
    MatchParent,
}
```

---

## å…·ä½“æ§ä»¶å®ç°

### 1. Button

#### Python å®ç°
```python
class Button(TextView):
    def __init__(self, activity: Activity, text: str, parent: Optional[View] = None, 
                 allcaps: bool = False):
        args = {"aid": activity.aid, "text": text, "allcaps": allcaps}
        if parent is not None:
            args["parent"] = parent.id
        View.__init__(self, activity, 
            activity.c.send_read_msg({"method": "createButton", "params": args}))
```

#### Rust å®ç°
```rust
pub struct Button {
    pub view: View,
}

impl Button {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        text: &str,
        parent: Option<i64>,
        allcaps: bool,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "text": text,
            "allcaps": allcaps
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createButton",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid Button ID")?;
        
        Ok(Button {
            view: View::new(activity_id, id),
        })
    }
    
    pub fn set_text(&self, stream: &mut UnixStream, text: &str) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "setText",
            "params": {
                "aid": self.view.activity_id,
                "id": self.view.id,
                "text": text
            }
        }))
    }
}
```

### 2. EditText

#### Python å®ç°
```python
class EditText(TextView):
    def __init__(self, activity: Activity, text: str, parent: Optional[View] = None,
                 singleline: bool = False, line: bool = True,
                 inputtype: Literal["text", "number", ...] = "text"):
        args = {"aid": activity.aid, "text": text, "singleline": singleline, 
                "line": line, "type": inputtype}
        if parent is not None:
            args["parent"] = parent.id
        View.__init__(self, activity,
            activity.c.send_read_msg({"method": "createEditText", "params": args}))
```

#### Rust å®ç°
```rust
pub enum InputType {
    Text,
    TextMultiLine,
    Number,
    NumberDecimal,
    Phone,
    Email,
    Password,
}

impl InputType {
    fn as_str(&self) -> &str {
        match self {
            InputType::Text => "text",
            InputType::TextMultiLine => "textMultiLine",
            InputType::Number => "number",
            InputType::NumberDecimal => "numberDecimal",
            InputType::Phone => "phone",
            InputType::Email => "textEmailAddress",
            InputType::Password => "textPassword",
        }
    }
}

pub struct EditText {
    pub view: View,
}

impl EditText {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        text: &str,
        parent: Option<i64>,
        singleline: bool,
        input_type: InputType,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "text": text,
            "singleline": singleline,
            "line": true,
            "blockinput": false,
            "type": input_type.as_str()
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createEditText",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid EditText ID")?;
        
        Ok(EditText {
            view: View::new(activity_id, id),
        })
    }
    
    pub fn get_text(&self, stream: &mut UnixStream) -> Result<String, Error> {
        let response = send_and_read(stream, &json!({
            "method": "getText",
            "params": {
                "aid": self.view.activity_id,
                "id": self.view.id
            }
        }))?;
        
        Ok(response.as_str().unwrap_or("").to_string())
    }
}
```

### 3. Checkbox

#### Python å®ç°
```python
class Checkbox(CompoundButton):
    def __init__(self, activity: Activity, text: str, parent: Optional[View] = None,
                 checked: bool = False):
        args = {"aid": activity.aid, "text": text, "checked": checked}
        if parent is not None:
            args["parent"] = parent.id
        self.checked = checked
        View.__init__(self, activity,
            activity.c.send_read_msg({"method": "createCheckbox", "params": args}))
```

#### Rust å®ç°
```rust
pub struct Checkbox {
    pub view: View,
}

impl Checkbox {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        text: &str,
        parent: Option<i64>,
        checked: bool,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "text": text,
            "checked": checked
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createCheckbox",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid Checkbox ID")?;
        
        Ok(Checkbox {
            view: View::new(activity_id, id),
        })
    }
    
    pub fn set_checked(&self, stream: &mut UnixStream, checked: bool) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "setChecked",
            "params": {
                "aid": self.view.activity_id,
                "id": self.view.id,
                "checked": checked
            }
        }))
    }
}
```

### 4. LinearLayout

#### Python å®ç°
```python
class LinearLayout(ViewGroup):
    def __init__(self, activity: Activity, parent: Optional[View] = None,
                 vertical: bool = True):
        args = {"aid": activity.aid, "vertical": vertical}
        if parent is not None:
            args["parent"] = parent.id
        ViewGroup.__init__(self, activity,
            activity.c.send_read_msg({"method": "createLinearLayout", "params": args}))
```

#### Rust å®ç°
```rust
pub struct LinearLayout {
    pub view: View,
}

impl LinearLayout {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        parent: Option<i64>,
        vertical: bool,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "vertical": vertical
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createLinearLayout",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid LinearLayout ID")?;
        
        Ok(LinearLayout {
            view: View::new(activity_id, id),
        })
    }
}
```

---

## å®Œæ•´ç¤ºä¾‹å¯¹æ¯”

### Python: å¸¦æŒ‰é’®çš„äº¤äº’å¼ç•Œé¢

```python
import termuxgui as tg
import sys

with tg.Connection() as c:
    a = tg.Activity(c, dialog=True)
    layout = tg.LinearLayout(a)
    
    title = tg.TextView(a, "Counter Demo", layout)
    title.settextsize(30)
    
    counter = tg.TextView(a, "Count: 0", layout)
    
    button = tg.Button(a, "Click Me!", layout)
    
    count = 0
    
    for ev in c.events():
        if ev.type == tg.Event.destroy and ev.value["finishing"]:
            sys.exit()
        
        if ev.type == tg.Event.click and ev.value["id"] == button:
            count += 1
            counter.settext(f"Count: {count}")
```

### Rust: å¯¹åº”å®ç°

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc::{channel, Sender};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ... è¿æ¥å»ºç«‹ä»£ç  ...
    
    let aid = create_activity(&mut main_stream)?;
    
    // åˆ›å»ºå¸ƒå±€
    let layout = LinearLayout::new(&mut main_stream, aid, None, true)?;
    
    // åˆ›å»ºæ ‡é¢˜
    let mut title_params = json!({
        "aid": aid,
        "text": "Counter Demo",
        "parent": layout.view.id
    });
    let title_id = send_and_read(&mut main_stream, &json!({
        "method": "createTextView",
        "params": title_params
    }))?.as_i64().unwrap();
    
    // è®¾ç½®æ ‡é¢˜å­—ä½“å¤§å°
    send_message(&mut main_stream, &json!({
        "method": "setTextSize",
        "params": {"aid": aid, "id": title_id, "size": 30}
    }))?;
    
    // åˆ›å»ºè®¡æ•°å™¨æ˜¾ç¤º
    let counter_id = send_and_read(&mut main_stream, &json!({
        "method": "createTextView",
        "params": {
            "aid": aid,
            "text": "Count: 0",
            "parent": layout.view.id
        }
    }))?.as_i64().unwrap();
    
    // åˆ›å»ºæŒ‰é’®
    let button = Button::new(
        &mut main_stream,
        aid,
        "Click Me!",
        Some(layout.view.id),
        false,
    )?;
    
    // å…±äº«çŠ¶æ€
    let count = Arc::new(Mutex::new(0));
    let count_clone = count.clone();
    
    // å…‹éš† main_stream ä¾›äº‹ä»¶å¤„ç†ä½¿ç”¨ï¼ˆæˆ–ä½¿ç”¨ channelï¼‰
    let (tx, rx) = channel();
    
    // äº‹ä»¶ç›‘å¬çº¿ç¨‹
    let event_thread = thread::spawn(move || {
        loop {
            match read_message(&mut event_stream) {
                Ok(event_json) => {
                    let event = Event::from_json(&event_json)?;
                    tx.send(event).unwrap();
                    
                    if event.event_type == EventType::Destroy {
                        break;
                    }
                },
                Err(e) => break,
            }
        }
    });
    
    // ä¸»äº‹ä»¶å¾ªç¯
    for event in rx {
        match event.event_type {
            EventType::Destroy => {
                if let EventData::Destroy { finishing: true } = event.data {
                    break;
                }
            },
            EventType::Click if event.view_id == Some(button.view.id) => {
                let mut count = count.lock().unwrap();
                *count += 1;
                
                // æ›´æ–°æ˜¾ç¤º
                send_message(&mut main_stream, &json!({
                    "method": "setText",
                    "params": {
                        "aid": aid,
                        "id": counter_id,
                        "text": format!("Count: {}", *count)
                    }
                }))?;
            },
            _ => {}
        }
    }
    
    event_thread.join().unwrap();
    Ok(())
}
```

---

## å®ç°æ¸…å•

### å·²å®ç° âœ…
- [x] åŸºç¡€è¿æ¥å’Œé€šä¿¡
- [x] Activity åˆ›å»º
- [x] TextView åˆ›å»ºå’Œæ›´æ–°
- [x] äº‹ä»¶ç›‘å¬çº¿ç¨‹
- [x] åŸºæœ¬äº‹ä»¶è§£æ

### å¾…å®ç° ğŸ“

#### æ ¸å¿ƒç»“æ„
- [ ] Event æšä¸¾å’Œè§£æ
- [ ] View åŸºç±»å’Œé€šç”¨æ–¹æ³•
- [ ] ViewGroup åŸºç±»

#### æ§ä»¶
- [ ] Button
- [ ] EditText
- [ ] Checkbox
- [ ] Switch
- [ ] RadioGroup / RadioButton
- [ ] Spinner
- [ ] ToggleButton

#### å¸ƒå±€
- [ ] LinearLayout
- [ ] FrameLayout
- [ ] GridLayout

#### äº‹ä»¶å¤„ç†
- [ ] äº‹ä»¶å›è°ƒç³»ç»Ÿ
- [ ] äº‹ä»¶è¿‡æ»¤å™¨
- [ ] è‡ªåŠ¨äº‹ä»¶åˆ†å‘

---

## ä¸‹ä¸€æ­¥å®ç°å»ºè®®

### é˜¶æ®µ1: æ ¸å¿ƒç»“æ„ï¼ˆ1-2å¤©ï¼‰
1. å®Œå–„ Event ç³»ç»Ÿ
2. å®ç° View åŸºç±»
3. å®ç°äº‹ä»¶åˆ†å‘æœºåˆ¶

### é˜¶æ®µ2: åŸºç¡€æ§ä»¶ï¼ˆ2-3å¤©ï¼‰
1. Button + ç‚¹å‡»äº‹ä»¶
2. EditText + æ–‡æœ¬äº‹ä»¶
3. Checkbox + çŠ¶æ€äº‹ä»¶
4. LinearLayout

### é˜¶æ®µ3: é«˜çº§åŠŸèƒ½ï¼ˆ3-5å¤©ï¼‰
1. RadioGroup/RadioButton
2. Spinner
3. å…¶ä»–å¸ƒå±€ç®¡ç†å™¨
4. äº‹ä»¶å›è°ƒç³»ç»Ÿä¼˜åŒ–

### é˜¶æ®µ4: åº“åŒ–ï¼ˆ5-7å¤©ï¼‰
1. æ¨¡å—åŒ–ä»£ç 
2. åˆ›å»º crate
3. æ–‡æ¡£å’Œç¤ºä¾‹
4. å‘å¸ƒåˆ° crates.io

---

## æœ€ä½³å®è·µå»ºè®®

### 1. ä½¿ç”¨ Arc<Mutex<>> å…±äº«çŠ¶æ€

```rust
let main_stream = Arc::new(Mutex::new(main_stream));
let stream_clone = main_stream.clone();
```

### 2. ä½¿ç”¨ channel ä¼ é€’äº‹ä»¶

```rust
let (event_tx, event_rx) = channel();

// äº‹ä»¶çº¿ç¨‹å‘é€
event_tx.send(event).unwrap();

// ä¸»çº¿ç¨‹æ¥æ”¶
for event in event_rx {
    handle_event(event);
}
```

### 3. ä½¿ç”¨ trait å®ç°å¤šæ€

```rust
pub trait Widget {
    fn get_view(&self) -> &View;
    fn set_text(&self, stream: &mut UnixStream, text: &str) -> Result<(), Error>;
}
```

### 4. ä½¿ç”¨ Builder æ¨¡å¼

```rust
Button::new()
    .text("Click Me")
    .color(0xFF0000)
    .allcaps(false)
    .build(stream, activity_id, parent)?;
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025  
**çŠ¶æ€**: è®¾è®¡å®Œæˆï¼Œå¾…å®ç°
