# Termux:GUI 事件和控件实现指南

## 概述

本文档详细说明如何在 Rust 版本中实现完整的事件处理和各种 GUI 控件，基于 Python 实现进行对比分析。

## 事件系统架构

### Python 实现分析

#### 事件类型（Event Types）

```python
class Event:
    # View 事件
    click = "click"                    # 点击事件
    longClick = "longClick"            # 长按事件
    focusChange = "focusChange"        # 焦点变化
    key = "key"                        # 按键事件
    touch = "touch"                    # 触摸事件
    refresh = "refresh"                # 刷新事件
    selected = "selected"              # 选中事件（RadioGroup）
    itemselected = "itemselected"      # 项目选中（Spinner）
    text = "text"                      # 文本变化（EditText）
    
    # Activity 事件
    create = "create"                  # Activity 创建
    start = "start"                    # Activity 启动
    resume = "resume"                  # Activity 恢复
    pause = "pause"                    # Activity 暂停
    stop = "stop"                      # Activity 停止
    destroy = "destroy"                # Activity 销毁
    back = "back"                      # 返回键
    
    # 其他事件
    notification = "notification"       # 通知点击
    webviewNavigation = "webviewNavigation"  # WebView 导航
```

#### 事件结构

```python
# 事件 JSON 格式
{
    "type": "click",           # 事件类型
    "value": {
        "aid": 0,             # Activity ID
        "id": 42,             # View ID
        # 额外字段根据事件类型不同
        "set": true,          # Checkbox/Switch 状态
        "selected": 1,        # 选中的项目
        "text": "content",    # EditText 内容
        "finishing": true     # Activity 是否正在结束
    }
}
```

### Rust 实现设计

#### 1. 事件枚举定义

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum EventType {
    // View 事件
    Click,
    LongClick,
    FocusChange,
    Key,
    Touch,
    Text,
    Refresh,
    Selected,
    ItemSelected,
    
    // Activity 事件
    Create,
    Start,
    Resume,
    Pause,
    Stop,
    Destroy,
    Back,
    
    // 其他
    Notification,
    WebviewNavigation,
    Unknown(String),
}

impl From<&str> for EventType {
    fn from(s: &str) -> Self {
        match s {
            "click" => EventType::Click,
            "longClick" => EventType::LongClick,
            "focusChange" => EventType::FocusChange,
            "text" => EventType::Text,
            "selected" => EventType::Selected,
            "itemselected" => EventType::ItemSelected,
            "create" => EventType::Create,
            "start" => EventType::Start,
            "resume" => EventType::Resume,
            "pause" => EventType::Pause,
            "stop" => EventType::Stop,
            "destroy" => EventType::Destroy,
            "back" => EventType::Back,
            _ => EventType::Unknown(s.to_string()),
        }
    }
}
```

#### 2. 事件数据结构

```rust
#[derive(Debug, Clone)]
pub struct Event {
    pub event_type: EventType,
    pub aid: Option<i64>,
    pub view_id: Option<i64>,
    pub data: EventData,
}

#[derive(Debug, Clone)]
pub enum EventData {
    Click,
    Checked { set: bool },                    // Checkbox/Switch
    Selected { selected: i64 },               // RadioGroup
    ItemSelected { selected: String },        // Spinner
    Text { text: String },                    // EditText
    Destroy { finishing: bool },
    None,
}

impl Event {
    pub fn from_json(value: &Value) -> Result<Self, String> {
        let event_type = value["type"]
            .as_str()
            .ok_or("Missing event type")?
            .into();
            
        let val = &value["value"];
        let aid = val["aid"].as_i64();
        let view_id = val["id"].as_i64();
        
        let data = match event_type {
            EventType::Click if val["set"].is_boolean() => {
                EventData::Checked {
                    set: val["set"].as_bool().unwrap(),
                }
            },
            EventType::Selected => {
                EventData::Selected {
                    selected: val["selected"].as_i64().unwrap_or(0),
                }
            },
            EventType::ItemSelected => {
                EventData::ItemSelected {
                    selected: val["selected"].as_str().unwrap_or("").to_string(),
                }
            },
            EventType::Text => {
                EventData::Text {
                    text: val["text"].as_str().unwrap_or("").to_string(),
                }
            },
            EventType::Destroy => {
                EventData::Destroy {
                    finishing: val["finishing"].as_bool().unwrap_or(false),
                }
            },
            _ => EventData::None,
        };
        
        Ok(Event {
            event_type,
            aid,
            view_id,
            data,
        })
    }
}
```

---

## 控件系统架构

### 基础 View 结构

#### Python 实现

```python
class View:
    def __init__(self, activity: Activity, id: int):
        self.a = activity
        self.id = id
    
    def delete(self):
        self.a.c.send_msg({
            "method": "deleteView",
            "params": {"aid": self.a.aid, "id": self.id}
        })
    
    def setwidth(self, width: Union[int, str], px: bool = False):
        self.a.c.send_msg({
            "method": "setWidth",
            "params": {"aid": self.a.aid, "id": self.id, "width": width, "px": px}
        })
```

#### Rust 实现

```rust
pub struct View {
    pub activity_id: i64,
    pub id: i64,
}

impl View {
    pub fn new(activity_id: i64, id: i64) -> Self {
        View { activity_id, id }
    }
    
    pub fn delete(&self, stream: &mut UnixStream) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "deleteView",
            "params": {
                "aid": self.activity_id,
                "id": self.id
            }
        }))
    }
    
    pub fn set_width(&self, stream: &mut UnixStream, width: ViewSize, px: bool) -> Result<(), Error> {
        let width_value = match width {
            ViewSize::Fixed(w) => json!(w),
            ViewSize::WrapContent => json!("WRAP_CONTENT"),
            ViewSize::MatchParent => json!("MATCH_PARENT"),
        };
        
        send_message(stream, &json!({
            "method": "setWidth",
            "params": {
                "aid": self.activity_id,
                "id": self.id,
                "width": width_value,
                "px": px
            }
        }))
    }
    
    pub fn set_background_color(&self, stream: &mut UnixStream, color: i32) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "setBackgroundColor",
            "params": {
                "aid": self.activity_id,
                "id": self.id,
                "color": color
            }
        }))
    }
    
    pub fn send_click_event(&self, stream: &mut UnixStream, send: bool) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "sendClickEvent",
            "params": {
                "aid": self.activity_id,
                "id": self.id,
                "send": send
            }
        }))
    }
}

pub enum ViewSize {
    Fixed(i32),
    WrapContent,
    MatchParent,
}
```

---

## 具体控件实现

### 1. Button

#### Python 实现
```python
class Button(TextView):
    def __init__(self, activity: Activity, text: str, parent: Optional[View] = None, 
                 allcaps: bool = False):
        args = {"aid": activity.aid, "text": text, "allcaps": allcaps}
        if parent is not None:
            args["parent"] = parent.id
        View.__init__(self, activity, 
            activity.c.send_read_msg({"method": "createButton", "params": args}))
```

#### Rust 实现
```rust
pub struct Button {
    pub view: View,
}

impl Button {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        text: &str,
        parent: Option<i64>,
        allcaps: bool,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "text": text,
            "allcaps": allcaps
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createButton",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid Button ID")?;
        
        Ok(Button {
            view: View::new(activity_id, id),
        })
    }
    
    pub fn set_text(&self, stream: &mut UnixStream, text: &str) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "setText",
            "params": {
                "aid": self.view.activity_id,
                "id": self.view.id,
                "text": text
            }
        }))
    }
}
```

### 2. EditText

#### Python 实现
```python
class EditText(TextView):
    def __init__(self, activity: Activity, text: str, parent: Optional[View] = None,
                 singleline: bool = False, line: bool = True,
                 inputtype: Literal["text", "number", ...] = "text"):
        args = {"aid": activity.aid, "text": text, "singleline": singleline, 
                "line": line, "type": inputtype}
        if parent is not None:
            args["parent"] = parent.id
        View.__init__(self, activity,
            activity.c.send_read_msg({"method": "createEditText", "params": args}))
```

#### Rust 实现
```rust
pub enum InputType {
    Text,
    TextMultiLine,
    Number,
    NumberDecimal,
    Phone,
    Email,
    Password,
}

impl InputType {
    fn as_str(&self) -> &str {
        match self {
            InputType::Text => "text",
            InputType::TextMultiLine => "textMultiLine",
            InputType::Number => "number",
            InputType::NumberDecimal => "numberDecimal",
            InputType::Phone => "phone",
            InputType::Email => "textEmailAddress",
            InputType::Password => "textPassword",
        }
    }
}

pub struct EditText {
    pub view: View,
}

impl EditText {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        text: &str,
        parent: Option<i64>,
        singleline: bool,
        input_type: InputType,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "text": text,
            "singleline": singleline,
            "line": true,
            "blockinput": false,
            "type": input_type.as_str()
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createEditText",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid EditText ID")?;
        
        Ok(EditText {
            view: View::new(activity_id, id),
        })
    }
    
    pub fn get_text(&self, stream: &mut UnixStream) -> Result<String, Error> {
        let response = send_and_read(stream, &json!({
            "method": "getText",
            "params": {
                "aid": self.view.activity_id,
                "id": self.view.id
            }
        }))?;
        
        Ok(response.as_str().unwrap_or("").to_string())
    }
}
```

### 3. Checkbox

#### Python 实现
```python
class Checkbox(CompoundButton):
    def __init__(self, activity: Activity, text: str, parent: Optional[View] = None,
                 checked: bool = False):
        args = {"aid": activity.aid, "text": text, "checked": checked}
        if parent is not None:
            args["parent"] = parent.id
        self.checked = checked
        View.__init__(self, activity,
            activity.c.send_read_msg({"method": "createCheckbox", "params": args}))
```

#### Rust 实现
```rust
pub struct Checkbox {
    pub view: View,
}

impl Checkbox {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        text: &str,
        parent: Option<i64>,
        checked: bool,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "text": text,
            "checked": checked
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createCheckbox",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid Checkbox ID")?;
        
        Ok(Checkbox {
            view: View::new(activity_id, id),
        })
    }
    
    pub fn set_checked(&self, stream: &mut UnixStream, checked: bool) -> Result<(), Error> {
        send_message(stream, &json!({
            "method": "setChecked",
            "params": {
                "aid": self.view.activity_id,
                "id": self.view.id,
                "checked": checked
            }
        }))
    }
}
```

### 4. LinearLayout

#### Python 实现
```python
class LinearLayout(ViewGroup):
    def __init__(self, activity: Activity, parent: Optional[View] = None,
                 vertical: bool = True):
        args = {"aid": activity.aid, "vertical": vertical}
        if parent is not None:
            args["parent"] = parent.id
        ViewGroup.__init__(self, activity,
            activity.c.send_read_msg({"method": "createLinearLayout", "params": args}))
```

#### Rust 实现
```rust
pub struct LinearLayout {
    pub view: View,
}

impl LinearLayout {
    pub fn new(
        stream: &mut UnixStream,
        activity_id: i64,
        parent: Option<i64>,
        vertical: bool,
    ) -> Result<Self, Error> {
        let mut params = json!({
            "aid": activity_id,
            "vertical": vertical
        });
        
        if let Some(parent_id) = parent {
            params["parent"] = json!(parent_id);
        }
        
        let response = send_and_read(stream, &json!({
            "method": "createLinearLayout",
            "params": params
        }))?;
        
        let id = response.as_i64().ok_or("Invalid LinearLayout ID")?;
        
        Ok(LinearLayout {
            view: View::new(activity_id, id),
        })
    }
}
```

---

## 完整示例对比

### Python: 带按钮的交互式界面

```python
import termuxgui as tg
import sys

with tg.Connection() as c:
    a = tg.Activity(c, dialog=True)
    layout = tg.LinearLayout(a)
    
    title = tg.TextView(a, "Counter Demo", layout)
    title.settextsize(30)
    
    counter = tg.TextView(a, "Count: 0", layout)
    
    button = tg.Button(a, "Click Me!", layout)
    
    count = 0
    
    for ev in c.events():
        if ev.type == tg.Event.destroy and ev.value["finishing"]:
            sys.exit()
        
        if ev.type == tg.Event.click and ev.value["id"] == button:
            count += 1
            counter.settext(f"Count: {count}")
```

### Rust: 对应实现

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc::{channel, Sender};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ... 连接建立代码 ...
    
    let aid = create_activity(&mut main_stream)?;
    
    // 创建布局
    let layout = LinearLayout::new(&mut main_stream, aid, None, true)?;
    
    // 创建标题
    let mut title_params = json!({
        "aid": aid,
        "text": "Counter Demo",
        "parent": layout.view.id
    });
    let title_id = send_and_read(&mut main_stream, &json!({
        "method": "createTextView",
        "params": title_params
    }))?.as_i64().unwrap();
    
    // 设置标题字体大小
    send_message(&mut main_stream, &json!({
        "method": "setTextSize",
        "params": {"aid": aid, "id": title_id, "size": 30}
    }))?;
    
    // 创建计数器显示
    let counter_id = send_and_read(&mut main_stream, &json!({
        "method": "createTextView",
        "params": {
            "aid": aid,
            "text": "Count: 0",
            "parent": layout.view.id
        }
    }))?.as_i64().unwrap();
    
    // 创建按钮
    let button = Button::new(
        &mut main_stream,
        aid,
        "Click Me!",
        Some(layout.view.id),
        false,
    )?;
    
    // 共享状态
    let count = Arc::new(Mutex::new(0));
    let count_clone = count.clone();
    
    // 克隆 main_stream 供事件处理使用（或使用 channel）
    let (tx, rx) = channel();
    
    // 事件监听线程
    let event_thread = thread::spawn(move || {
        loop {
            match read_message(&mut event_stream) {
                Ok(event_json) => {
                    let event = Event::from_json(&event_json)?;
                    tx.send(event).unwrap();
                    
                    if event.event_type == EventType::Destroy {
                        break;
                    }
                },
                Err(e) => break,
            }
        }
    });
    
    // 主事件循环
    for event in rx {
        match event.event_type {
            EventType::Destroy => {
                if let EventData::Destroy { finishing: true } = event.data {
                    break;
                }
            },
            EventType::Click if event.view_id == Some(button.view.id) => {
                let mut count = count.lock().unwrap();
                *count += 1;
                
                // 更新显示
                send_message(&mut main_stream, &json!({
                    "method": "setText",
                    "params": {
                        "aid": aid,
                        "id": counter_id,
                        "text": format!("Count: {}", *count)
                    }
                }))?;
            },
            _ => {}
        }
    }
    
    event_thread.join().unwrap();
    Ok(())
}
```

---

## 实现清单

### 已实现 ✅
- [x] 基础连接和通信
- [x] Activity 创建
- [x] TextView 创建和更新
- [x] 事件监听线程
- [x] 基本事件解析

### 待实现 📝

#### 核心结构
- [ ] Event 枚举和解析
- [ ] View 基类和通用方法
- [ ] ViewGroup 基类

#### 控件
- [ ] Button
- [ ] EditText
- [ ] Checkbox
- [ ] Switch
- [ ] RadioGroup / RadioButton
- [ ] Spinner
- [ ] ToggleButton

#### 布局
- [ ] LinearLayout
- [ ] FrameLayout
- [ ] GridLayout

#### 事件处理
- [ ] 事件回调系统
- [ ] 事件过滤器
- [ ] 自动事件分发

---

## 下一步实现建议

### 阶段1: 核心结构（1-2天）
1. 完善 Event 系统
2. 实现 View 基类
3. 实现事件分发机制

### 阶段2: 基础控件（2-3天）
1. Button + 点击事件
2. EditText + 文本事件
3. Checkbox + 状态事件
4. LinearLayout

### 阶段3: 高级功能（3-5天）
1. RadioGroup/RadioButton
2. Spinner
3. 其他布局管理器
4. 事件回调系统优化

### 阶段4: 库化（5-7天）
1. 模块化代码
2. 创建 crate
3. 文档和示例
4. 发布到 crates.io

---

## 最佳实践建议

### 1. 使用 Arc<Mutex<>> 共享状态

```rust
let main_stream = Arc::new(Mutex::new(main_stream));
let stream_clone = main_stream.clone();
```

### 2. 使用 channel 传递事件

```rust
let (event_tx, event_rx) = channel();

// 事件线程发送
event_tx.send(event).unwrap();

// 主线程接收
for event in event_rx {
    handle_event(event);
}
```

### 3. 使用 trait 实现多态

```rust
pub trait Widget {
    fn get_view(&self) -> &View;
    fn set_text(&self, stream: &mut UnixStream, text: &str) -> Result<(), Error>;
}
```

### 4. 使用 Builder 模式

```rust
Button::new()
    .text("Click Me")
    .color(0xFF0000)
    .allcaps(false)
    .build(stream, activity_id, parent)?;
```

---

**文档版本**: v1.0  
**最后更新**: 2025  
**状态**: 设计完成，待实现
