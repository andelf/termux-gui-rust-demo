# 退出事件处理指南

## 问题现象

运行 `input_demo` 或 `button_demo` 时，当手动关闭界面（按返回键或点击外部），界面消失但**命令行还在等待**，没有退出。

## 原因分析

### destroy 事件的两种情况

根据 Termux:GUI 协议，`destroy` 事件有一个 `finishing` 字段：

```json
{
    "type": "destroy",
    "value": {
        "aid": 0,
        "finishing": true/false
    }
}
```

**finishing 字段含义**:
- `true`: Activity 正在被销毁且不会重建（真正退出）
- `false`: Activity 暂时销毁但可能重建（如旋转屏幕、进入后台）

### 当前代码的问题

**示例程序的检查**:
```rust
"destroy" if event_value["finishing"].as_bool().unwrap_or(false) => {
    println!("\n✓ Activity 已关闭");
    break;
}
```

**潜在问题**:
1. 如果 `finishing` 字段不存在，`unwrap_or(false)` 返回 `false`
2. 条件不满足，不会 `break`
3. 程序继续等待事件

### Python 版本的对比

Python 示例有两种处理方式：

**方式 1: 只检查类型**
```python
if ev.type == tg.Event.destroy:
    sys.exit()
```

**方式 2: 检查 finishing**
```python
if ev.type == tg.Event.destroy and ev.value["finishing"]:
    sys.exit()
```

## 解决方案

### 方案 1: 简化条件（推荐）

只要收到 `destroy` 事件就退出，不检查 `finishing`：

```rust
match event_type {
    "destroy" => {
        println!("\n✓ Activity 已关闭");
        break;
    },
    // ... 其他事件
}
```

**优点**:
- 简单可靠
- 适用于大多数场景
- 不会"卡住"

**缺点**:
- 无法区分真正退出和暂时销毁

### 方案 2: 更宽松的条件检查

```rust
match event_type {
    "destroy" => {
        let finishing = event_value["finishing"].as_bool().unwrap_or(true);  // 默认 true
        if finishing {
            println!("\n✓ Activity 已关闭");
            break;
        } else {
            println!("⚠️  Activity 暂时销毁");
        }
    },
    // ... 其他事件
}
```

**优点**:
- 可以区分不同的销毁原因
- 如果字段不存在，默认退出（更安全）

### 方案 3: 双重检查

```rust
match event_type {
    "destroy" => {
        let finishing = event_value["finishing"].as_bool();
        println!("收到 destroy 事件，finishing: {:?}", finishing);
        
        if finishing.is_none() || finishing == Some(true) {
            println!("\n✓ Activity 已关闭");
            break;
        } else {
            println!("⚠️  Activity 暂时销毁");
        }
    },
    // ... 其他事件
}
```

**优点**:
- 最完整的处理
- 有日志可以调试

### 方案 4: 添加超时机制

```rust
use std::time::{Duration, Instant};

let start_time = Instant::now();
let timeout = Duration::from_secs(300); // 5分钟超时

loop {
    // 检查超时
    if start_time.elapsed() > timeout {
        println!("⚠️  超时，自动退出");
        break;
    }
    
    // 设置 socket 读取超时
    event_stream.set_read_timeout(Some(Duration::from_secs(1)))?;
    
    match read_message(&mut event_stream) {
        Ok(event) => {
            // 处理事件
        },
        Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
            // 超时但不退出，继续循环
            continue;
        },
        Err(e) => {
            println!("❌ 读取错误: {}", e);
            break;
        }
    }
}
```

## 推荐修复

### 对于示例程序

**修改前**:
```rust
"destroy" if event_value["finishing"].as_bool().unwrap_or(false) => {
    println!("\n✓ Activity 已关闭");
    break;
},
```

**修改后（推荐）**:
```rust
"destroy" => {
    println!("\n✓ Activity 已关闭");
    break;
},
```

或者更详细的版本：

```rust
"destroy" => {
    let finishing = event_value["finishing"].as_bool().unwrap_or(true);
    println!("\n收到 destroy 事件 (finishing: {})", finishing);
    if finishing {
        println!("✓ Activity 已关闭");
        break;
    }
},
```

## 调试方法

### 1. 使用 test_events 工具

```bash
cargo run --example test_events --release
```

这个工具会打印所有收到的事件，包括完整的 JSON 内容，帮助你：
- 查看 `finishing` 字段的实际值
- 确认是否收到 `destroy` 事件
- 观察事件的完整结构

### 2. 添加调试日志

在事件循环中添加：

```rust
loop {
    let event = read_message(&mut event_stream)?;
    
    // 打印所有事件
    println!("DEBUG: {:?}", event);
    
    let event_type = event["type"].as_str().unwrap_or("");
    // ...
}
```

### 3. 检查事件流

```bash
# 运行程序并保存输出
cargo run --example input_demo --release 2>&1 | tee events.log

# 手动关闭界面后，查看日志
cat events.log
```

## 对话框模式的特殊性

对话框模式 (`dialog: true`) 的 Activity 行为可能不同：

```rust
// 对话框模式
{
    "method": "newActivity",
    "params": {"dialog": true, "canceloutside": false}
}
```

**canceloutside 参数**:
- `false`: 点击外部不关闭，**只能按返回键**
- `true`: 点击外部可关闭

如果设置了 `canceloutside: false`，可能需要：
1. 按返回键才能关闭
2. 或者添加一个"关闭"按钮

## 实际测试

### 测试 1: 简单的 destroy 处理

```rust
match event_type {
    "destroy" => {
        println!("收到 destroy 事件: {}", event);
        break;
    },
    _ => {}
}
```

### 测试 2: 带 finishing 检查

```rust
match event_type {
    "destroy" => {
        match event_value["finishing"].as_bool() {
            Some(true) => {
                println!("finishing=true, 退出");
                break;
            },
            Some(false) => {
                println!("finishing=false, 继续");
            },
            None => {
                println!("finishing 不存在, 退出");
                break;
            }
        }
    },
    _ => {}
}
```

## 最佳实践

### 1. 对于简单应用

```rust
"destroy" => {
    break;  // 收到就退出
}
```

### 2. 对于需要保存状态的应用

```rust
"destroy" => {
    let finishing = event_value["finishing"].as_bool().unwrap_or(true);
    if finishing {
        // 保存数据
        save_state();
        break;
    }
}
```

### 3. 对于长期运行的应用

```rust
"destroy" => {
    let finishing = event_value["finishing"].as_bool().unwrap_or(true);
    if finishing {
        // 清理资源
        cleanup();
        break;
    } else {
        // 保存状态但不退出
        save_state();
    }
}
```

## 总结

**立即修复**:
1. 将 `unwrap_or(false)` 改为 `unwrap_or(true)`
2. 或者直接不检查 `finishing`，只检查 `destroy` 类型

**长期改进**:
1. 添加超时机制
2. 添加详细的事件日志
3. 使用 `test_events` 工具调试

**推荐代码**:
```rust
match event_type {
    "destroy" => {
        println!("\n✓ Activity 已关闭");
        break;
    },
    // ... 其他事件
}
```

---

**创建时间**: 2025  
**相关工具**: test_events.rs  
**状态**: 待修复
